{"ast":null,"code":"import n from \"lodash/uniq\";\nimport t from \"lodash/uniqBy\";\nimport r from \"lodash/sortBy\";\nimport e from \"lodash/last\";\nimport a from \"lodash/isDate\";\nimport { utcParse as i, timeParse as o } from \"d3-time-format\";\nimport { scaleLinear as u, scalePoint as c, scaleBand as f, scaleUtc as d, scaleTime as s, scaleLog as l, scaleSymlog as m } from \"d3-scale\";\nimport { timeInterval as v, timeMillisecond as y, utcMillisecond as p, timeSecond as h, utcSecond as g, timeMinute as x, utcMinute as k, timeHour as T, utcHour as M, timeWeek as w, utcWeek as b, timeSunday as E, utcSunday as S, timeMonday as D, utcMonday as C, timeTuesday as U, utcTuesday as j, timeWednesday as O, utcWednesday as R, timeThursday as H, utcThursday as V, timeFriday as q, utcFriday as A, timeSaturday as B, utcSaturday as F, timeMonth as N, utcMonth as z, timeYear as I, utcYear as P } from \"d3-time\";\nfunction $() {\n  return $ = Object.assign || function (n) {\n    for (var t = 1; t < arguments.length; t++) {\n      var r = arguments[t];\n      for (var e in r) Object.prototype.hasOwnProperty.call(r, e) && (n[e] = r[e]);\n    }\n    return n;\n  }, $.apply(this, arguments);\n}\nvar G = [\"millisecond\", \"second\", \"minute\", \"hour\", \"day\", \"month\", \"year\"],\n  J = [function (n) {\n    return n.setMilliseconds(0);\n  }, function (n) {\n    return n.setSeconds(0);\n  }, function (n) {\n    return n.setMinutes(0);\n  }, function (n) {\n    return n.setHours(0);\n  }, function (n) {\n    return n.setDate(1);\n  }, function (n) {\n    return n.setMonth(0);\n  }],\n  K = {\n    millisecond: [],\n    second: J.slice(0, 1),\n    minute: J.slice(0, 2),\n    hour: J.slice(0, 3),\n    day: J.slice(0, 4),\n    month: J.slice(0, 5),\n    year: J.slice(0, 6)\n  },\n  L = function (n) {\n    return function (t) {\n      return K[n].forEach(function (n) {\n        n(t);\n      }), t;\n    };\n  },\n  Q = function (n) {\n    var t = n.format,\n      r = void 0 === t ? \"native\" : t,\n      e = n.precision,\n      a = void 0 === e ? \"millisecond\" : e,\n      u = n.useUTC,\n      c = void 0 === u || u,\n      f = L(a);\n    return function (n) {\n      if (void 0 === n) return n;\n      if (\"native\" === r || n instanceof Date) return f(n);\n      var t = c ? i(r) : o(r);\n      return f(t(n));\n    };\n  },\n  W = function (n, t, r, e) {\n    var a,\n      i,\n      o,\n      c,\n      f = n.min,\n      d = void 0 === f ? 0 : f,\n      s = n.max,\n      l = void 0 === s ? \"auto\" : s,\n      m = n.stacked,\n      v = void 0 !== m && m,\n      y = n.reverse,\n      p = void 0 !== y && y,\n      h = n.clamp,\n      g = void 0 !== h && h,\n      x = n.nice,\n      k = void 0 !== x && x;\n    \"auto\" === d ? a = !0 === v ? null != (i = t.minStacked) ? i : 0 : t.min : a = d;\n    \"auto\" === l ? o = !0 === v ? null != (c = t.maxStacked) ? c : 0 : t.max : o = l;\n    var T = u().rangeRound(\"x\" === e ? [0, r] : [r, 0]).domain(p ? [o, a] : [a, o]).clamp(g);\n    return !0 === k ? T.nice() : \"number\" == typeof k && T.nice(k), X(T, v);\n  },\n  X = function (n, t) {\n    void 0 === t && (t = !1);\n    var r = n;\n    return r.type = \"linear\", r.stacked = t, r;\n  },\n  Y = function (n, t, r) {\n    var e = c().range([0, r]).domain(t.all);\n    return e.type = \"point\", e;\n  },\n  Z = function (n) {\n    var t = n;\n    return t.type = \"point\", t;\n  },\n  _ = function (n, t, r, e) {\n    var a = n.round,\n      i = void 0 === a || a,\n      o = f().range(\"x\" === e ? [0, r] : [r, 0]).domain(t.all).round(i);\n    return nn(o);\n  },\n  nn = function (n) {\n    var t = n;\n    return t.type = \"band\", t;\n  },\n  tn = function (n, t, r) {\n    var e,\n      a,\n      i = n.format,\n      o = void 0 === i ? \"native\" : i,\n      u = n.precision,\n      c = void 0 === u ? \"millisecond\" : u,\n      f = n.min,\n      l = void 0 === f ? \"auto\" : f,\n      m = n.max,\n      v = void 0 === m ? \"auto\" : m,\n      y = n.useUTC,\n      p = void 0 === y || y,\n      h = n.nice,\n      g = void 0 !== h && h,\n      x = Q({\n        format: o,\n        precision: c,\n        useUTC: p\n      });\n    e = \"auto\" === l ? x(t.min) : \"native\" !== o ? x(l) : l, a = \"auto\" === v ? x(t.max) : \"native\" !== o ? x(v) : v;\n    var k = p ? d() : s();\n    k.range([0, r]), e && a && k.domain([e, a]), !0 === g ? k.nice() : \"object\" != typeof g && \"number\" != typeof g || k.nice(g);\n    var T = k;\n    return T.type = \"time\", T.useUTC = p, T;\n  },\n  rn = function (n, t, r, e) {\n    var a,\n      i = n.base,\n      o = void 0 === i ? 10 : i,\n      u = n.min,\n      c = void 0 === u ? \"auto\" : u,\n      f = n.max,\n      d = void 0 === f ? \"auto\" : f;\n    if (t.all.some(function (n) {\n      return 0 === n;\n    })) throw new Error(\"a log scale domain must not include or cross zero\");\n    var s,\n      m,\n      v = !1;\n    if (t.all.filter(function (n) {\n      return null != n;\n    }).forEach(function (n) {\n      v || (void 0 === a ? a = Math.sign(n) : Math.sign(n) !== a && (v = !0));\n    }), v) throw new Error(\"a log scale domain must be strictly-positive or strictly-negative\");\n    s = \"auto\" === c ? t.min : c, m = \"auto\" === d ? t.max : d;\n    var y = l().domain([s, m]).rangeRound(\"x\" === e ? [0, r] : [r, 0]).base(o).nice();\n    return y.type = \"log\", y;\n  },\n  en = function (n, t, r, e) {\n    var a,\n      i,\n      o = n.constant,\n      u = void 0 === o ? 1 : o,\n      c = n.min,\n      f = void 0 === c ? \"auto\" : c,\n      d = n.max,\n      s = void 0 === d ? \"auto\" : d,\n      l = n.reverse,\n      v = void 0 !== l && l;\n    a = \"auto\" === f ? t.min : f, i = \"auto\" === s ? t.max : s;\n    var y = m().constant(u).rangeRound(\"x\" === e ? [0, r] : [r, 0]).nice();\n    !0 === v ? y.domain([i, a]) : y.domain([a, i]);\n    var p = y;\n    return p.type = \"symlog\", p;\n  },\n  an = function (n) {\n    return \"x\" === n ? \"y\" : \"x\";\n  },\n  on = function (n, t) {\n    return n === t;\n  },\n  un = function (n, t) {\n    return n.getTime() === t.getTime();\n  };\nfunction cn(n, t, r, e) {\n  switch (n.type) {\n    case \"linear\":\n      return W(n, t, r, e);\n    case \"point\":\n      return Y(0, t, r);\n    case \"band\":\n      return _(n, t, r, e);\n    case \"time\":\n      return tn(n, t, r);\n    case \"log\":\n      return rn(n, t, r, e);\n    case \"symlog\":\n      return en(n, t, r, e);\n    default:\n      throw new Error(\"invalid scale spec\");\n  }\n}\nvar fn = function (n, t, r) {\n    var e;\n    if (\"stacked\" in r && r.stacked) {\n      var a = n.data[\"x\" === t ? \"xStacked\" : \"yStacked\"];\n      return null == a ? null : r(a);\n    }\n    return null != (e = r(n.data[t])) ? e : null;\n  },\n  dn = function (n, t, r, e, a) {\n    var i = n.map(function (n) {\n        return function (n) {\n          return $({}, n, {\n            data: n.data.map(function (n) {\n              return {\n                data: $({}, n)\n              };\n            })\n          });\n        }(n);\n      }),\n      o = sn(i, t, r);\n    \"stacked\" in t && !0 === t.stacked && vn(o, i), \"stacked\" in r && !0 === r.stacked && yn(o, i);\n    var u = cn(t, o.x, e, \"x\"),\n      c = cn(r, o.y, a, \"y\"),\n      f = i.map(function (n) {\n        return $({}, n, {\n          data: n.data.map(function (n) {\n            return $({}, n, {\n              position: {\n                x: fn(n, \"x\", u),\n                y: fn(n, \"y\", c)\n              }\n            });\n          })\n        });\n      });\n    return $({}, o, {\n      series: f,\n      xScale: u,\n      yScale: c\n    });\n  },\n  sn = function (n, t, r) {\n    return {\n      x: ln(n, \"x\", t),\n      y: ln(n, \"y\", r)\n    };\n  },\n  ln = function (a, i, o, u) {\n    var c = void 0 === u ? {} : u,\n      f = c.getValue,\n      d = void 0 === f ? function (n) {\n        return n.data[i];\n      } : f,\n      s = c.setValue,\n      l = void 0 === s ? function (n, t) {\n        n.data[i] = t;\n      } : s;\n    if (\"linear\" === o.type) a.forEach(function (n) {\n      n.data.forEach(function (n) {\n        var t = d(n);\n        t && l(n, parseFloat(String(t)));\n      });\n    });else if (\"time\" === o.type && \"native\" !== o.format) {\n      var m = Q(o);\n      a.forEach(function (n) {\n        n.data.forEach(function (n) {\n          var t = d(n);\n          t && l(n, m(t));\n        });\n      });\n    }\n    var v = [];\n    switch (a.forEach(function (n) {\n      n.data.forEach(function (n) {\n        v.push(d(n));\n      });\n    }), o.type) {\n      case \"linear\":\n        var y = r(n(v).filter(function (n) {\n          return null !== n;\n        }), function (n) {\n          return n;\n        });\n        return {\n          all: y,\n          min: Math.min.apply(Math, y),\n          max: Math.max.apply(Math, y)\n        };\n      case \"time\":\n        var p = t(v, function (n) {\n          return n.getTime();\n        }).slice(0).sort(function (n, t) {\n          return t.getTime() - n.getTime();\n        }).reverse();\n        return {\n          all: p,\n          min: p[0],\n          max: e(p)\n        };\n      default:\n        var h = n(v);\n        return {\n          all: h,\n          min: h[0],\n          max: e(h)\n        };\n    }\n  },\n  mn = function (n, t, r) {\n    var i = an(n),\n      o = [];\n    t[i].all.forEach(function (t) {\n      var u = a(t) ? un : on,\n        c = [];\n      r.forEach(function (r) {\n        var a = r.data.find(function (n) {\n            return u(n.data[i], t);\n          }),\n          f = null,\n          d = null;\n        if (void 0 !== a) {\n          if (null !== (f = a.data[n])) {\n            var s = e(c);\n            void 0 === s ? d = f : null !== s && (d = s + f);\n          }\n          a.data[\"x\" === n ? \"xStacked\" : \"yStacked\"] = d;\n        }\n        c.push(d), null !== d && o.push(d);\n      });\n    }), t[n].minStacked = Math.min.apply(Math, o), t[n].maxStacked = Math.max.apply(Math, o);\n  },\n  vn = function (n, t) {\n    return mn(\"x\", n, t);\n  },\n  yn = function (n, t) {\n    return mn(\"y\", n, t);\n  },\n  pn = function (n) {\n    var t = n.bandwidth();\n    if (0 === t) return n;\n    var r = t / 2;\n    return n.round() && (r = Math.round(r)), function (t) {\n      var e;\n      return (null != (e = n(t)) ? e : 0) + r;\n    };\n  },\n  hn = {\n    millisecond: [y, p],\n    second: [h, g],\n    minute: [x, k],\n    hour: [T, M],\n    day: [v(function (n) {\n      return n.setHours(0, 0, 0, 0);\n    }, function (n, t) {\n      return n.setDate(n.getDate() + t);\n    }, function (n, t) {\n      return (t.getTime() - n.getTime()) / 864e5;\n    }, function (n) {\n      return Math.floor(n.getTime() / 864e5);\n    }), v(function (n) {\n      return n.setUTCHours(0, 0, 0, 0);\n    }, function (n, t) {\n      return n.setUTCDate(n.getUTCDate() + t);\n    }, function (n, t) {\n      return (t.getTime() - n.getTime()) / 864e5;\n    }, function (n) {\n      return Math.floor(n.getTime() / 864e5);\n    })],\n    week: [w, b],\n    sunday: [E, S],\n    monday: [D, C],\n    tuesday: [U, j],\n    wednesday: [O, R],\n    thursday: [H, V],\n    friday: [q, A],\n    saturday: [B, F],\n    month: [N, z],\n    year: [I, P]\n  },\n  gn = Object.keys(hn),\n  xn = new RegExp(\"^every\\\\s*(\\\\d+)?\\\\s*(\" + gn.join(\"|\") + \")s?$\", \"i\"),\n  kn = function (n, t) {\n    if (Array.isArray(t)) return t;\n    if (\"string\" == typeof t && \"useUTC\" in n) {\n      var r = t.match(xn);\n      if (r) {\n        var e = r[1],\n          a = r[2],\n          i = hn[a][n.useUTC ? 1 : 0];\n        if (\"day\" === a) {\n          var o,\n            u,\n            c = n.domain(),\n            f = c[0],\n            d = c[1],\n            s = new Date(d);\n          return s.setDate(s.getDate() + 1), null != (o = null == (u = i.every(Number(null != e ? e : 1))) ? void 0 : u.range(f, s)) ? o : [];\n        }\n        if (void 0 === e) return n.ticks(i);\n        var l = i.every(Number(e));\n        if (l) return n.ticks(l);\n      }\n      throw new Error(\"Invalid tickValues: \" + t);\n    }\n    if (\"ticks\" in n) {\n      if (void 0 === t) return n.ticks();\n      if (\"number\" == typeof (m = t) && isFinite(m) && Math.floor(m) === m) return n.ticks(t);\n    }\n    var m;\n    return n.domain();\n  };\nexport { nn as castBandScale, X as castLinearScale, Z as castPointScale, pn as centerScale, un as compareDateValues, on as compareValues, cn as computeScale, dn as computeXYScalesForSeries, _ as createBandScale, Q as createDateNormalizer, W as createLinearScale, rn as createLogScale, Y as createPointScale, L as createPrecisionMethod, en as createSymlogScale, tn as createTimeScale, ln as generateSeriesAxis, sn as generateSeriesXY, an as getOtherAxis, kn as getScaleTicks, J as precisionCutOffs, K as precisionCutOffsByType, mn as stackAxis, G as timePrecisions };","map":{"version":3,"mappings":"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","names":["timePrecisions","precisionCutOffs","date","setMilliseconds","setSeconds","setMinutes","setHours","setDate","setMonth","precisionCutOffsByType","millisecond","second","slice","minute","hour","day","month","year","createPrecisionMethod","precision","forEach","cutOff","createDateNormalizer","format","e","u","useUTC","precisionFn","value","undefined","Date","parseTime","utcParse","timeParse","createLinearScale","data","size","axis","minValue","maxValue","min","s","max","m","stacked","reverse","clamp","nice","minStacked","maxStacked","scale","scaleLinear","rangeRound","domain","castLinearScale","typedScale","type","createPointScale","_spec","scalePoint","range","all","castPointScale","createBandScale","round","scaleBand","castBandScale","createTimeScale","f","y","normalize","scaleUtc","scaleTime","createLogScale","sign","base","some","v","Error","hasMixedSign","filter","Math","scaleLog","createSymlogScale","constant","c","d","l","scaleSymlog","getOtherAxis","compareValues","a","b","compareDateValues","getTime","computeScale","spec","getDatumAxisPosition","datum","stackedValue","computeXYScalesForSeries","series","xScaleSpec","yScaleSpec","width","height","nestedSeries","map","serie","nestSerieData","xy","generateSeriesXY","stackX","stackY","xScale","x","yScale","computedSeries","position","generateSeriesAxis","scaleSpec","getValue","setValue","parseFloat","String","values","push","sortBy","uniq","uniqBy","sort","last","stackAxis","otherAxis","compare","isDate","stack","find","stackValue","head","centerScale","bandwidth","offset","timeByType","timeMillisecond","utcMillisecond","timeSecond","utcSecond","timeMinute","utcMinute","timeHour","utcHour","timeInterval","step","getDate","start","end","floor","setUTCHours","setUTCDate","getUTCDate","week","timeWeek","utcWeek","sunday","timeSunday","utcSunday","monday","timeMonday","utcMonday","tuesday","timeTuesday","utcTuesday","wednesday","timeWednesday","utcWednesday","thursday","timeThursday","utcThursday","friday","timeFriday","utcFriday","saturday","timeSaturday","utcSaturday","timeMonth","utcMonth","timeYear","utcYear","timeTypes","Object","keys","timeIntervalRegexp","RegExp","join","getScaleTicks","Array","isArray","matches","match","amount","timeType","originalStop","stop","every","Number","_timeType$every","ticks","interval","isFinite"],"sources":["/Users/ilerioluwakiiye/Desktop/Dev/fin-trakaa/node_modules/@nivo/scales/src/timeHelpers.ts","/Users/ilerioluwakiiye/Desktop/Dev/fin-trakaa/node_modules/@nivo/scales/src/linearScale.ts","/Users/ilerioluwakiiye/Desktop/Dev/fin-trakaa/node_modules/@nivo/scales/src/pointScale.ts","/Users/ilerioluwakiiye/Desktop/Dev/fin-trakaa/node_modules/@nivo/scales/src/bandScale.ts","/Users/ilerioluwakiiye/Desktop/Dev/fin-trakaa/node_modules/@nivo/scales/src/timeScale.ts","/Users/ilerioluwakiiye/Desktop/Dev/fin-trakaa/node_modules/@nivo/scales/src/logScale.ts","/Users/ilerioluwakiiye/Desktop/Dev/fin-trakaa/node_modules/@nivo/scales/src/symlogScale.ts","/Users/ilerioluwakiiye/Desktop/Dev/fin-trakaa/node_modules/@nivo/scales/src/compute.ts","/Users/ilerioluwakiiye/Desktop/Dev/fin-trakaa/node_modules/@nivo/scales/src/ticks.ts"],"sourcesContent":["import { timeParse, utcParse } from 'd3-time-format'\n\nexport const timePrecisions = [\n    'millisecond',\n    'second',\n    'minute',\n    'hour',\n    'day',\n    'month',\n    'year',\n] as const\n\nexport type TIME_PRECISION = typeof timePrecisions[number]\n\nexport const precisionCutOffs: ((date: Date) => void)[] = [\n    date => date.setMilliseconds(0),\n    date => date.setSeconds(0),\n    date => date.setMinutes(0),\n    date => date.setHours(0),\n    date => date.setDate(1),\n    date => date.setMonth(0),\n]\n\nexport const precisionCutOffsByType: Record<TIME_PRECISION, ((date: Date) => void)[]> = {\n    millisecond: [],\n    second: precisionCutOffs.slice(0, 1),\n    minute: precisionCutOffs.slice(0, 2),\n    hour: precisionCutOffs.slice(0, 3),\n    day: precisionCutOffs.slice(0, 4),\n    month: precisionCutOffs.slice(0, 5),\n    year: precisionCutOffs.slice(0, 6),\n}\n\nexport const createPrecisionMethod = (precision: TIME_PRECISION) => (date: Date) => {\n    precisionCutOffsByType[precision].forEach(cutOff => {\n        cutOff(date)\n    })\n\n    return date\n}\n\nexport const createDateNormalizer = ({\n    format = 'native',\n    precision = 'millisecond',\n    useUTC = true,\n}: {\n    format?: 'native' | string\n    precision?: TIME_PRECISION\n    useUTC?: boolean\n}) => {\n    const precisionFn = createPrecisionMethod(precision)\n\n    return (value: Date | string | undefined) => {\n        if (value === undefined) {\n            return value\n        }\n\n        if (format === 'native' || value instanceof Date) {\n            return precisionFn(value as Date)\n        }\n\n        const parseTime = useUTC ? utcParse(format) : timeParse(format)\n        return precisionFn(parseTime(value as string) as Date)\n    }\n}\n","import { NumberValue, scaleLinear, ScaleLinear as D3ScaleLinear } from 'd3-scale'\nimport { ScaleLinearSpec, ScaleLinear, ComputedSerieAxis, ScaleAxis } from './types'\n\nexport const createLinearScale = <Output extends NumberValue>(\n    {\n        min = 0,\n        max = 'auto',\n        stacked = false,\n        reverse = false,\n        clamp = false,\n        nice = false,\n    }: ScaleLinearSpec,\n    data: ComputedSerieAxis<Output>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: NumberValue\n    if (min === 'auto') {\n        minValue = stacked === true ? data.minStacked ?? 0 : data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: NumberValue\n    if (max === 'auto') {\n        maxValue = stacked === true ? data.maxStacked ?? 0 : data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLinear<number, Output>()\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .domain(reverse ? [maxValue, minValue] : [minValue, maxValue])\n        .clamp(clamp)\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'number') scale.nice(nice)\n\n    return castLinearScale<number, Output>(scale, stacked)\n}\n\nexport const castLinearScale = <Range, Output>(\n    scale: D3ScaleLinear<Range, Output>,\n    stacked = false\n) => {\n    const typedScale = scale as unknown as ScaleLinear<number>\n    typedScale.type = 'linear'\n    typedScale.stacked = stacked\n\n    return typedScale\n}\n","import { scalePoint, ScalePoint as D3ScalePoint } from 'd3-scale'\nimport { ComputedSerieAxis, ScalePoint, ScalePointSpec, StringValue } from './types'\n\nexport const createPointScale = <Input extends StringValue>(\n    _spec: ScalePointSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number\n) => {\n    const scale = scalePoint<Input>().range([0, size]).domain(data.all)\n\n    const typedScale = scale as ScalePoint<Input>\n    typedScale.type = 'point'\n\n    return typedScale\n}\n\nexport const castPointScale = <Input extends StringValue>(scale: D3ScalePoint<Input>) => {\n    const typedScale = scale as ScalePoint<Input>\n    typedScale.type = 'point'\n\n    return typedScale\n}\n","import { scaleBand, ScaleBand as D3ScaleBand } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleBand, ScaleBandSpec, StringValue, ScaleAxis } from './types'\n\nexport const createBandScale = <Input extends StringValue>(\n    { round = true }: ScaleBandSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const scale = scaleBand<Input>()\n        .range(axis === 'x' ? [0, size] : [size, 0])\n        .domain(data.all)\n        .round(round)\n\n    return castBandScale<Input>(scale)\n}\n\nexport const castBandScale = <Input>(scale: D3ScaleBand<Input>) => {\n    const typedScale = scale as ScaleBand<Input>\n    typedScale.type = 'band'\n\n    return typedScale\n}\n","import { NumberValue, scaleTime, scaleUtc } from 'd3-scale'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ComputedSerieAxis, ScaleTime, ScaleTimeSpec } from './types'\n\nexport const createTimeScale = <Input extends Date | NumberValue>(\n    {\n        format = 'native',\n        precision = 'millisecond',\n        min = 'auto',\n        max = 'auto',\n        useUTC = true,\n        nice = false,\n    }: ScaleTimeSpec,\n    data: ComputedSerieAxis<string | Date>,\n    size: number\n) => {\n    const normalize = createDateNormalizer({ format, precision, useUTC })\n\n    let minValue: Date | undefined\n    if (min === 'auto') {\n        minValue = normalize(data.min)\n    } else if (format !== 'native') {\n        minValue = normalize(min)\n    } else {\n        minValue = min as Date\n    }\n\n    let maxValue: Date | undefined\n    if (max === 'auto') {\n        maxValue = normalize(data.max)\n    } else if (format !== 'native') {\n        maxValue = normalize(max)\n    } else {\n        maxValue = max as Date\n    }\n\n    const scale = useUTC ? scaleUtc() : scaleTime()\n\n    scale.range([0, size])\n\n    if (minValue && maxValue) scale.domain([minValue, maxValue])\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'object' || typeof nice === 'number') scale.nice(nice)\n\n    const typedScale = scale as unknown as ScaleTime<Input>\n\n    typedScale.type = 'time'\n    typedScale.useUTC = useUTC\n\n    return typedScale\n}\n","import { scaleLog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleLog, ScaleLogSpec } from './types'\n\nexport const createLogScale = (\n    { base = 10, min = 'auto', max = 'auto' }: ScaleLogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const hasZero = data.all.some(v => v === 0)\n    if (hasZero) {\n        throw new Error(`a log scale domain must not include or cross zero`)\n    }\n\n    let sign: number\n    let hasMixedSign = false\n    data.all\n        .filter(v => v != null)\n        .forEach(v => {\n            if (hasMixedSign) return\n            if (sign === undefined) {\n                sign = Math.sign(v)\n            } else if (Math.sign(v) !== sign) {\n                hasMixedSign = true\n            }\n        })\n\n    if (hasMixedSign) {\n        throw new Error(`a log scale domain must be strictly-positive or strictly-negative`)\n    }\n\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLog<number, number>()\n        .domain([minValue, maxValue])\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .base(base)\n        .nice()\n\n    const typedScale = scale as ScaleLog\n    typedScale.type = 'log'\n\n    return typedScale\n}\n","import { scaleSymlog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleSymlog, ScaleSymlogSpec } from './types'\n\nexport const createSymlogScale = (\n    { constant = 1, min = 'auto', max = 'auto', reverse = false }: ScaleSymlogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleSymlog<number, number>()\n        .constant(constant)\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .nice()\n\n    if (reverse === true) scale.domain([maxValue, minValue])\n    else scale.domain([minValue, maxValue])\n\n    const typedScale = scale as ScaleSymlog\n    typedScale.type = 'symlog'\n\n    return typedScale\n}\n","import uniq from 'lodash/uniq'\nimport uniqBy from 'lodash/uniqBy'\nimport sortBy from 'lodash/sortBy'\nimport last from 'lodash/last'\nimport isDate from 'lodash/isDate'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ScaleAxis, ScaleSpec, ScaleValue, SerieAxis, ComputedSerieAxis } from './types'\nimport { createLinearScale } from './linearScale'\nimport { createPointScale } from './pointScale'\nimport { createBandScale } from './bandScale'\nimport { createTimeScale } from './timeScale'\nimport { createLogScale } from './logScale'\nimport { createSymlogScale } from './symlogScale'\n\ntype XY = ReturnType<typeof generateSeriesXY>\n\ntype StackedXY = {\n    [K in keyof XY]: XY[K] & {\n        maxStacked: number\n        minStacked: number\n    }\n}\n\ninterface SerieDatum {\n    x: number | string | Date\n    // only numbers can be stacked\n    xStacked?: number | null\n    y: number | string | Date\n    // only numbers can be stacked\n    yStacked?: number | null\n}\n\ntype Serie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: D[]\n}\n\ntype NestedSerie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: {\n        data: D\n    }[]\n}\n\nexport type ComputedSerie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: {\n        data: D\n        position: {\n            x: number | null\n            y: number | null\n        }\n    }[]\n}\n\ntype Compare = <T>(a: T, b: T) => boolean\n\nexport const getOtherAxis = (axis: ScaleAxis): ScaleAxis => (axis === 'x' ? 'y' : 'x')\n\nexport const compareValues = (a: string | number, b: string | number) => a === b\nexport const compareDateValues = (a: Date, b: Date) => a.getTime() === b.getTime()\n\nexport function computeScale<Input extends ScaleValue>(\n    spec: ScaleSpec,\n    data: ComputedSerieAxis<any>,\n    size: number,\n    axis: ScaleAxis\n) {\n    switch (spec.type) {\n        case 'linear':\n            return createLinearScale(spec, data, size, axis)\n        case 'point':\n            return createPointScale<Input>(spec, data, size)\n        case 'band':\n            return createBandScale<Input>(spec, data, size, axis)\n        case 'time':\n            return createTimeScale(spec, data, size)\n        case 'log':\n            return createLogScale(spec, data, size, axis)\n        case 'symlog':\n            return createSymlogScale(spec, data, size, axis)\n        default:\n            throw new Error('invalid scale spec')\n    }\n}\n\n/**\n * Convert serie data to have the original data stored in a nested prop.\n *\n * We do this in order to avoid conflicts between raw & computed properties.\n * <- { data: { x: 1, y: 3 }[] }\n * -> { data: { data: { x: 1, y: 3 } }[] }\n */\nconst nestSerieData = <S = never, D extends SerieDatum = SerieDatum>(\n    serie: Serie<S, D>\n): NestedSerie<S, D> => ({\n    ...serie,\n    data: serie.data.map(d => ({ data: { ...d } })),\n})\n\nconst getDatumAxisPosition = <D extends SerieDatum = SerieDatum>(\n    datum: { data: D },\n    axis: ScaleAxis,\n    scale: any\n): number | null => {\n    if ('stacked' in scale && scale.stacked) {\n        const stackedValue = datum.data[axis === 'x' ? 'xStacked' : 'yStacked']\n        if (stackedValue === null || stackedValue === undefined) {\n            return null\n        }\n\n        return scale(stackedValue)\n    }\n\n    return scale(datum.data[axis]) ?? null\n}\n\n/**\n * Compute x/y d3 scales from an array of data series, and scale specifications.\n *\n * We use generics as it's not uncommon to have extra properties such as an id\n * added to the series, or extra props on data, in such case, you should override\n * the default types.\n */\nexport const computeXYScalesForSeries = <S = never, D extends SerieDatum = SerieDatum>(\n    series: Serie<S, D>[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec,\n    width: number,\n    height: number\n) => {\n    // first nest series to avoid property conflicts\n    const nestedSeries = series.map(serie => nestSerieData<S, D>(serie))\n\n    // then compute data for each axis: all, min, max values\n    const xy = generateSeriesXY<S, D>(nestedSeries, xScaleSpec, yScaleSpec)\n\n    // stack x values depending on xScale\n    if ('stacked' in xScaleSpec && xScaleSpec.stacked === true) {\n        stackX<S, D>(xy as StackedXY, nestedSeries)\n    }\n\n    // stack y values depending on yScale\n    if ('stacked' in yScaleSpec && yScaleSpec.stacked === true) {\n        stackY<S, D>(xy as StackedXY, nestedSeries)\n    }\n\n    // computes scales\n    const xScale = computeScale<D['x']>(xScaleSpec, xy.x, width, 'x')\n    const yScale = computeScale<D['y']>(yScaleSpec, xy.y, height, 'y')\n\n    // assign position to each datum in every scale\n    const computedSeries: ComputedSerie<S, D>[] = nestedSeries.map(serie => ({\n        ...serie,\n        data: serie.data.map(datum => ({\n            ...datum,\n            position: {\n                x: getDatumAxisPosition(datum, 'x', xScale),\n                y: getDatumAxisPosition(datum, 'y', yScale),\n            },\n        })),\n    }))\n\n    return {\n        ...xy,\n        series: computedSeries,\n        xScale,\n        yScale,\n    }\n}\n\nexport const generateSeriesXY = <S = never, D extends SerieDatum = SerieDatum>(\n    series: NestedSerie<S, D>[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec\n) => ({\n    x: generateSeriesAxis<'x', D['x']>(series, 'x', xScaleSpec),\n    y: generateSeriesAxis<'y', D['y']>(series, 'y', yScaleSpec),\n})\n\n/**\n * Normalize data according to scale type, (time => Date, linear => Number)\n * compute sorted unique values and min/max.\n */\nexport const generateSeriesAxis = <Axis extends ScaleAxis, Value extends ScaleValue>(\n    series: SerieAxis<Axis, Value>,\n    axis: Axis,\n    scaleSpec: ScaleSpec,\n    {\n        getValue = d => d.data[axis],\n        setValue = (d, v) => {\n            d.data[axis] = v\n        },\n    }: {\n        getValue?: (d: { data: Record<Axis, Value | null> }) => Value | null\n        setValue?: (d: { data: Record<Axis, Value | null> }, v: Value) => void\n    } = {}\n) => {\n    if (scaleSpec.type === 'linear') {\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, parseFloat(String(value)) as unknown as Value)\n                }\n            })\n        })\n    } else if (scaleSpec.type === 'time' && scaleSpec.format !== 'native') {\n        // `native` means we already have Date instances,\n        // otherwise we have to convert the values to Date.\n        const parseTime = createDateNormalizer(scaleSpec)\n\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, parseTime(value as Date) as unknown as Value)\n                }\n            })\n        })\n    }\n\n    const values: unknown[] = []\n\n    series.forEach(serie => {\n        serie.data.forEach(d => {\n            values.push(getValue(d))\n        })\n    })\n\n    switch (scaleSpec.type) {\n        case 'linear': {\n            const all = sortBy(\n                // filer null values to deal with holes in linechart\n                uniq(values as number[]).filter(v => v !== null),\n                v => v\n            )\n\n            return { all, min: Math.min(...all), max: Math.max(...all) }\n        }\n        case 'time': {\n            const all = uniqBy(values as Date[], v => v.getTime())\n                .slice(0)\n                .sort((a, b) => b.getTime() - a.getTime())\n                .reverse()\n\n            return { all, min: all[0], max: last(all) }\n        }\n        default: {\n            const all = uniq(values)\n\n            return { all, min: all[0], max: last(all) }\n        }\n    }\n}\n\nexport const stackAxis = <S = never, D extends SerieDatum = SerieDatum>(\n    axis: ScaleAxis,\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => {\n    const otherAxis = getOtherAxis(axis)\n    const all: number[] = []\n\n    xy[otherAxis].all.forEach(v => {\n        const compare = (isDate(v) ? compareDateValues : compareValues) as Compare\n        const stack: Array<number | null> = []\n\n        series.forEach(serie => {\n            const datum = serie.data.find(d => compare(d.data[otherAxis], v))\n            let value = null\n            let stackValue = null\n\n            if (datum !== undefined) {\n                // stacked values only support numbers\n                value = datum.data[axis] as number\n                if (value !== null) {\n                    const head = last(stack)\n                    if (head === undefined) {\n                        stackValue = value\n                    } else if (head !== null) {\n                        stackValue = head + value\n                    }\n                }\n\n                datum.data[axis === 'x' ? 'xStacked' : 'yStacked'] = stackValue\n            }\n\n            stack.push(stackValue)\n\n            if (stackValue !== null) {\n                all.push(stackValue)\n            }\n        })\n    })\n\n    xy[axis].minStacked = Math.min(...all)\n    xy[axis].maxStacked = Math.max(...all)\n}\n\nconst stackX = <S = never, D extends SerieDatum = SerieDatum>(\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => stackAxis<S, D>('x', xy, series)\n\nconst stackY = <S = never, D extends SerieDatum = SerieDatum>(\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => stackAxis<S, D>('y', xy, series)\n","import {\n    CountableTimeInterval,\n    timeMillisecond,\n    utcMillisecond,\n    timeSecond,\n    utcSecond,\n    timeMinute,\n    utcMinute,\n    timeHour,\n    utcHour,\n    timeWeek,\n    utcWeek,\n    timeSunday,\n    utcSunday,\n    timeMonday,\n    utcMonday,\n    timeTuesday,\n    utcTuesday,\n    timeWednesday,\n    utcWednesday,\n    timeThursday,\n    utcThursday,\n    timeFriday,\n    utcFriday,\n    timeSaturday,\n    utcSaturday,\n    timeMonth,\n    utcMonth,\n    timeYear,\n    utcYear,\n    timeInterval,\n} from 'd3-time'\nimport { ScaleValue, TicksSpec, AnyScale, ScaleWithBandwidth } from './types'\n\nexport const centerScale = <Value>(scale: ScaleWithBandwidth) => {\n    const bandwidth = scale.bandwidth()\n\n    if (bandwidth === 0) return scale\n\n    let offset = bandwidth / 2\n    if (scale.round()) {\n        offset = Math.round(offset)\n    }\n\n    return <T extends Value>(d: T) => (scale(d) ?? 0) + offset\n}\n\nconst timeDay = timeInterval(\n    date => date.setHours(0, 0, 0, 0),\n    (date, step) => date.setDate(date.getDate() + step),\n    (start, end) => (end.getTime() - start.getTime()) / 864e5,\n    date => Math.floor(date.getTime() / 864e5)\n)\n\nconst utcDay = timeInterval(\n    date => date.setUTCHours(0, 0, 0, 0),\n    (date, step) => date.setUTCDate(date.getUTCDate() + step),\n    (start, end) => (end.getTime() - start.getTime()) / 864e5,\n    date => Math.floor(date.getTime() / 864e5)\n)\n\nconst timeByType: Record<string, [CountableTimeInterval, CountableTimeInterval]> = {\n    millisecond: [timeMillisecond, utcMillisecond],\n    second: [timeSecond, utcSecond],\n    minute: [timeMinute, utcMinute],\n    hour: [timeHour, utcHour],\n    day: [timeDay, utcDay],\n    week: [timeWeek, utcWeek],\n    sunday: [timeSunday, utcSunday],\n    monday: [timeMonday, utcMonday],\n    tuesday: [timeTuesday, utcTuesday],\n    wednesday: [timeWednesday, utcWednesday],\n    thursday: [timeThursday, utcThursday],\n    friday: [timeFriday, utcFriday],\n    saturday: [timeSaturday, utcSaturday],\n    month: [timeMonth, utcMonth],\n    year: [timeYear, utcYear],\n}\n\nconst timeTypes = Object.keys(timeByType)\nconst timeIntervalRegexp = new RegExp(`^every\\\\s*(\\\\d+)?\\\\s*(${timeTypes.join('|')})s?$`, 'i')\n\nconst isInteger = (value: unknown): value is number =>\n    typeof value === 'number' && isFinite(value) && Math.floor(value) === value\n\nexport const getScaleTicks = <Value extends ScaleValue>(\n    scale: AnyScale,\n    spec?: TicksSpec<Value>\n) => {\n    // specific values\n    if (Array.isArray(spec)) {\n        return spec\n    }\n\n    if (typeof spec === 'string' && 'useUTC' in scale) {\n        // time interval\n        const matches = spec.match(timeIntervalRegexp)\n\n        if (matches) {\n            const [, amount, type] = matches\n            // UTC is used as it's more predictable\n            // however local time could be used too\n            // let's see how it fits users' requirements\n            const timeType = timeByType[type][scale.useUTC ? 1 : 0]\n\n            if (type === 'day') {\n                const [start, originalStop] = scale.domain()\n                const stop = new Date(originalStop)\n\n                // Set range to include last day in the domain since `interval.range` function is exclusive stop\n                stop.setDate(stop.getDate() + 1)\n\n                return timeType.every(Number(amount ?? 1))?.range(start, stop) ?? []\n            }\n\n            if (amount === undefined) {\n                return scale.ticks(timeType)\n            }\n\n            const interval = timeType.every(Number(amount))\n\n            if (interval) {\n                return scale.ticks(interval)\n            }\n        }\n\n        throw new Error(`Invalid tickValues: ${spec}`)\n    }\n\n    // continuous scales\n    if ('ticks' in scale) {\n        // default behaviour\n        if (spec === undefined) {\n            return scale.ticks()\n        }\n\n        // specific tick count\n        if (isInteger(spec)) {\n            return scale.ticks(spec)\n        }\n    }\n\n    // non linear scale default\n    return scale.domain()\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}