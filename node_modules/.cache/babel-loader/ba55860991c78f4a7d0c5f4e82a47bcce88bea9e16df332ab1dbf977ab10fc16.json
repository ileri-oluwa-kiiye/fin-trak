{"ast":null,"code":"import { isValidElement as t, useMemo as n, createElement as i } from \"react\";\nimport o from \"lodash/omit\";\nimport e from \"lodash/isNumber\";\nimport a from \"lodash/filter\";\nimport { absoluteAngleDegrees as r, radiansToDegrees as s, positionFromAngle as l, degreesToRadians as u, useTheme as h, useMotionConfig as d, useAnimatedPath as c } from \"@nivo/core\";\nimport { useSpring as f, animated as y } from \"@react-spring/web\";\nimport { jsxs as x, Fragment as m, jsx as p } from \"react/jsx-runtime\";\nfunction g() {\n  return g = Object.assign || function (t) {\n    for (var n = 1; n < arguments.length; n++) {\n      var i = arguments[n];\n      for (var o in i) Object.prototype.hasOwnProperty.call(i, o) && (t[o] = i[o]);\n    }\n    return t;\n  }, g.apply(this, arguments);\n}\nvar k = {\n    dotSize: 4,\n    noteWidth: 120,\n    noteTextOffset: 8,\n    animate: !0,\n    motionStiffness: 90,\n    motionDamping: 13\n  },\n  W = function (n) {\n    var i = typeof n;\n    return t(n) || \"string\" === i || \"function\" === i || \"object\" === i;\n  },\n  v = function (t) {\n    var n = typeof t;\n    return \"string\" === n || \"function\" === n;\n  },\n  b = function (t) {\n    return \"circle\" === t.type;\n  },\n  w = function (t) {\n    return \"dot\" === t.type;\n  },\n  z = function (t) {\n    return \"rect\" === t.type;\n  },\n  P = function (t) {\n    var n = t.data,\n      i = t.annotations,\n      e = t.getPosition,\n      r = t.getDimensions;\n    return i.reduce(function (t, i) {\n      var s = i.offset || 0;\n      return [].concat(t, a(n, i.match).map(function (t) {\n        var n = e(t),\n          a = r(t);\n        return (b(i) || z(i)) && (a.size = a.size + 2 * s, a.width = a.width + 2 * s, a.height = a.height + 2 * s), g({}, o(i, [\"match\", \"offset\"]), n, a, {\n          size: i.size || a.size,\n          datum: t\n        });\n      }));\n    }, []);\n  },\n  S = function (t, n, i, o) {\n    var e = Math.atan2(o - n, i - t);\n    return r(s(e));\n  },\n  C = function (t) {\n    var n,\n      i,\n      o = t.x,\n      a = t.y,\n      r = t.noteX,\n      s = t.noteY,\n      h = t.noteWidth,\n      d = void 0 === h ? k.noteWidth : h,\n      c = t.noteTextOffset,\n      f = void 0 === c ? k.noteTextOffset : c;\n    if (e(r)) n = o + r;else {\n      if (void 0 === r.abs) throw new Error(\"noteX should be either a number or an object containing an 'abs' property\");\n      n = r.abs;\n    }\n    if (e(s)) i = a + s;else {\n      if (void 0 === s.abs) throw new Error(\"noteY should be either a number or an object containing an 'abs' property\");\n      i = s.abs;\n    }\n    var y = o,\n      x = a,\n      m = S(o, a, n, i);\n    if (b(t)) {\n      var p = l(u(m), t.size / 2);\n      y += p.x, x += p.y;\n    }\n    if (z(t)) {\n      var g = Math.round((m + 90) / 45) % 8;\n      0 === g && (x -= t.height / 2), 1 === g && (y += t.width / 2, x -= t.height / 2), 2 === g && (y += t.width / 2), 3 === g && (y += t.width / 2, x += t.height / 2), 4 === g && (x += t.height / 2), 5 === g && (y -= t.width / 2, x += t.height / 2), 6 === g && (y -= t.width / 2), 7 === g && (y -= t.width / 2, x -= t.height / 2);\n    }\n    var W = n,\n      v = n;\n    return (m + 90) % 360 > 180 ? (W -= d, v -= d) : v += d, {\n      points: [[y, x], [n, i], [v, i]],\n      text: [W, i - f],\n      angle: m + 90\n    };\n  },\n  O = function (t) {\n    var i = t.data,\n      o = t.annotations,\n      e = t.getPosition,\n      a = t.getDimensions;\n    return n(function () {\n      return P({\n        data: i,\n        annotations: o,\n        getPosition: e,\n        getDimensions: a\n      });\n    }, [i, o, e, a]);\n  },\n  j = function (t) {\n    var i = t.annotations;\n    return n(function () {\n      return i.map(function (t) {\n        return g({}, t, {\n          computed: C(g({}, t))\n        });\n      });\n    }, [i]);\n  },\n  M = function (t) {\n    return n(function () {\n      return C(t);\n    }, [t]);\n  },\n  T = function (t) {\n    var n = t.datum,\n      e = t.x,\n      a = t.y,\n      r = t.note,\n      s = h(),\n      l = d(),\n      u = l.animate,\n      c = l.config,\n      k = f({\n        x: e,\n        y: a,\n        config: c,\n        immediate: !u\n      });\n    return \"function\" == typeof r ? i(r, {\n      x: e,\n      y: a,\n      datum: n\n    }) : x(m, {\n      children: [s.annotations.text.outlineWidth > 0 && p(y.text, {\n        x: k.x,\n        y: k.y,\n        style: g({}, s.annotations.text, {\n          strokeLinejoin: \"round\",\n          strokeWidth: 2 * s.annotations.text.outlineWidth,\n          stroke: s.annotations.text.outlineColor\n        }),\n        children: r\n      }), p(y.text, {\n        x: k.x,\n        y: k.y,\n        style: o(s.annotations.text, [\"outlineWidth\", \"outlineColor\"]),\n        children: r\n      })]\n    });\n  },\n  E = function (t) {\n    var i = t.points,\n      o = t.isOutline,\n      e = void 0 !== o && o,\n      a = h(),\n      r = n(function () {\n        var t = i[0];\n        return i.slice(1).reduce(function (t, n) {\n          return t + \" L\" + n[0] + \",\" + n[1];\n        }, \"M\" + t[0] + \",\" + t[1]);\n      }, [i]),\n      s = c(r);\n    if (e && a.annotations.link.outlineWidth <= 0) return null;\n    var l = g({}, a.annotations.link);\n    return e && (l.strokeLinecap = \"square\", l.strokeWidth = a.annotations.link.strokeWidth + 2 * a.annotations.link.outlineWidth, l.stroke = a.annotations.link.outlineColor, l.opacity = a.annotations.link.outlineOpacity), p(y.path, {\n      fill: \"none\",\n      d: s,\n      style: l\n    });\n  },\n  D = function (t) {\n    var n = t.x,\n      i = t.y,\n      o = t.size,\n      e = h(),\n      a = d(),\n      r = a.animate,\n      s = a.config,\n      l = f({\n        x: n,\n        y: i,\n        radius: o / 2,\n        config: s,\n        immediate: !r\n      });\n    return x(m, {\n      children: [e.annotations.outline.outlineWidth > 0 && p(y.circle, {\n        cx: l.x,\n        cy: l.y,\n        r: l.radius,\n        style: g({}, e.annotations.outline, {\n          fill: \"none\",\n          strokeWidth: e.annotations.outline.strokeWidth + 2 * e.annotations.outline.outlineWidth,\n          stroke: e.annotations.outline.outlineColor,\n          opacity: e.annotations.outline.outlineOpacity\n        })\n      }), p(y.circle, {\n        cx: l.x,\n        cy: l.y,\n        r: l.radius,\n        style: e.annotations.outline\n      })]\n    });\n  },\n  I = function (t) {\n    var n = t.x,\n      i = t.y,\n      o = t.size,\n      e = void 0 === o ? k.dotSize : o,\n      a = h(),\n      r = d(),\n      s = r.animate,\n      l = r.config,\n      u = f({\n        x: n,\n        y: i,\n        radius: e / 2,\n        config: l,\n        immediate: !s\n      });\n    return x(m, {\n      children: [a.annotations.outline.outlineWidth > 0 && p(y.circle, {\n        cx: u.x,\n        cy: u.y,\n        r: u.radius,\n        style: g({}, a.annotations.outline, {\n          fill: \"none\",\n          strokeWidth: 2 * a.annotations.outline.outlineWidth,\n          stroke: a.annotations.outline.outlineColor,\n          opacity: a.annotations.outline.outlineOpacity\n        })\n      }), p(y.circle, {\n        cx: u.x,\n        cy: u.y,\n        r: u.radius,\n        style: a.annotations.symbol\n      })]\n    });\n  },\n  L = function (t) {\n    var n = t.x,\n      i = t.y,\n      o = t.width,\n      e = t.height,\n      a = t.borderRadius,\n      r = void 0 === a ? 6 : a,\n      s = h(),\n      l = d(),\n      u = l.animate,\n      c = l.config,\n      k = f({\n        x: n - o / 2,\n        y: i - e / 2,\n        width: o,\n        height: e,\n        config: c,\n        immediate: !u\n      });\n    return x(m, {\n      children: [s.annotations.outline.outlineWidth > 0 && p(y.rect, {\n        x: k.x,\n        y: k.y,\n        rx: r,\n        ry: r,\n        width: k.width,\n        height: k.height,\n        style: g({}, s.annotations.outline, {\n          fill: \"none\",\n          strokeWidth: s.annotations.outline.strokeWidth + 2 * s.annotations.outline.outlineWidth,\n          stroke: s.annotations.outline.outlineColor,\n          opacity: s.annotations.outline.outlineOpacity\n        })\n      }), p(y.rect, {\n        x: k.x,\n        y: k.y,\n        rx: r,\n        ry: r,\n        width: k.width,\n        height: k.height,\n        style: s.annotations.outline\n      })]\n    });\n  },\n  R = function (t) {\n    var n = t.datum,\n      i = t.x,\n      o = t.y,\n      e = t.note,\n      a = M(t);\n    if (!W(e)) throw new Error(\"note should be a valid react element\");\n    return x(m, {\n      children: [p(E, {\n        points: a.points,\n        isOutline: !0\n      }), b(t) && p(D, {\n        x: i,\n        y: o,\n        size: t.size\n      }), w(t) && p(I, {\n        x: i,\n        y: o,\n        size: t.size\n      }), z(t) && p(L, {\n        x: i,\n        y: o,\n        width: t.width,\n        height: t.height,\n        borderRadius: t.borderRadius\n      }), p(E, {\n        points: a.points\n      }), p(T, {\n        datum: n,\n        x: a.text[0],\n        y: a.text[1],\n        note: e\n      })]\n    });\n  },\n  q = function (t, n) {\n    n.forEach(function (n, i) {\n      var o = n[0],\n        e = n[1];\n      0 === i ? t.moveTo(o, e) : t.lineTo(o, e);\n    });\n  },\n  J = function (t, n) {\n    var i = n.annotations,\n      o = n.theme;\n    0 !== i.length && (t.save(), i.forEach(function (n) {\n      if (!v(n.note)) throw new Error(\"note is invalid for canvas implementation\");\n      o.annotations.link.outlineWidth > 0 && (t.lineCap = \"square\", t.strokeStyle = o.annotations.link.outlineColor, t.lineWidth = o.annotations.link.strokeWidth + 2 * o.annotations.link.outlineWidth, t.beginPath(), q(t, n.computed.points), t.stroke(), t.lineCap = \"butt\"), b(n) && o.annotations.outline.outlineWidth > 0 && (t.strokeStyle = o.annotations.outline.outlineColor, t.lineWidth = o.annotations.outline.strokeWidth + 2 * o.annotations.outline.outlineWidth, t.beginPath(), t.arc(n.x, n.y, n.size / 2, 0, 2 * Math.PI), t.stroke()), w(n) && o.annotations.symbol.outlineWidth > 0 && (t.strokeStyle = o.annotations.symbol.outlineColor, t.lineWidth = 2 * o.annotations.symbol.outlineWidth, t.beginPath(), t.arc(n.x, n.y, n.size / 2, 0, 2 * Math.PI), t.stroke()), z(n) && o.annotations.outline.outlineWidth > 0 && (t.strokeStyle = o.annotations.outline.outlineColor, t.lineWidth = o.annotations.outline.strokeWidth + 2 * o.annotations.outline.outlineWidth, t.beginPath(), t.rect(n.x - n.width / 2, n.y - n.height / 2, n.width, n.height), t.stroke()), t.strokeStyle = o.annotations.link.stroke, t.lineWidth = o.annotations.link.strokeWidth, t.beginPath(), q(t, n.computed.points), t.stroke(), b(n) && (t.strokeStyle = o.annotations.outline.stroke, t.lineWidth = o.annotations.outline.strokeWidth, t.beginPath(), t.arc(n.x, n.y, n.size / 2, 0, 2 * Math.PI), t.stroke()), w(n) && (t.fillStyle = o.annotations.symbol.fill, t.beginPath(), t.arc(n.x, n.y, n.size / 2, 0, 2 * Math.PI), t.fill()), z(n) && (t.strokeStyle = o.annotations.outline.stroke, t.lineWidth = o.annotations.outline.strokeWidth, t.beginPath(), t.rect(n.x - n.width / 2, n.y - n.height / 2, n.width, n.height), t.stroke()), \"function\" == typeof n.note ? n.note(t, {\n        datum: n.datum,\n        x: n.computed.text[0],\n        y: n.computed.text[1],\n        theme: o\n      }) : (t.font = o.annotations.text.fontSize + \"px \" + o.annotations.text.fontFamily, t.textAlign = \"left\", t.textBaseline = \"alphabetic\", t.fillStyle = o.annotations.text.fill, t.strokeStyle = o.annotations.text.outlineColor, t.lineWidth = 2 * o.annotations.text.outlineWidth, o.annotations.text.outlineWidth > 0 && (t.lineJoin = \"round\", t.strokeText(n.note, n.computed.text[0], n.computed.text[1]), t.lineJoin = \"miter\"), t.fillText(n.note, n.computed.text[0], n.computed.text[1]));\n    }), t.restore());\n  };\nexport { R as Annotation, P as bindAnnotations, C as computeAnnotation, k as defaultProps, S as getLinkAngle, v as isCanvasNote, b as isCircleAnnotation, w as isDotAnnotation, z as isRectAnnotation, W as isSvgNote, J as renderAnnotationsToCanvas, O as useAnnotations, M as useComputedAnnotation, j as useComputedAnnotations };","map":{"version":3,"mappings":"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","names":["defaultProps","dotSize","noteWidth","noteTextOffset","animate","motionStiffness","motionDamping","isSvgNote","note","noteType","isValidElement","isCanvasNote","isCircleAnnotation","annotationSpec","type","isDotAnnotation","isRectAnnotation","bindAnnotations","data","annotations","getPosition","getDimensions","reduce","acc","annotation","offset","_filter","match","map","datum","position","dimensions","size","width","height","_omit","getLinkAngle","sourceX","sourceY","targetX","targetY","angle","Math","atan2","absoluteAngleDegrees","radiansToDegrees","computeAnnotation","computedNoteX","computedNoteY","x","y","noteX","noteY","_isNumber","undefined","abs","Error","computedX","computedY","positionFromAngle","degreesToRadians","eighth","round","textX","noteLineX","points","text","useAnnotations","useMemo","useComputedAnnotations","computed","useComputedAnnotation","AnnotationNote","theme","useTheme","useMotionConfig","springConfig","config","animatedProps","useSpring","immediate","createElement","_jsxs","outlineWidth","_jsx","animated","style","strokeLinejoin","strokeWidth","stroke","outlineColor","omit","children","AnnotationLink","isOutline","path","firstPoint","animatedPath","useAnimatedPath","link","strokeLinecap","opacity","outlineOpacity","fill","d","CircleAnnotationOutline","radius","outline","circle","cx","cy","r","DotAnnotationOutline","symbol","RectAnnotationOutline","borderRadius","rect","rx","ry","Annotation","drawPoints","ctx","forEach","index","moveTo","lineTo","renderAnnotationsToCanvas","length","save","lineCap","strokeStyle","lineWidth","beginPath","arc","PI","fillStyle","font","fontSize","fontFamily","textAlign","textBaseline","lineJoin","strokeText","fillText","restore"],"sources":["/Users/ilerioluwakiiye/Desktop/Dev/fin-trakaa/node_modules/@nivo/annotations/src/props.ts","/Users/ilerioluwakiiye/Desktop/Dev/fin-trakaa/node_modules/@nivo/annotations/src/utils.ts","/Users/ilerioluwakiiye/Desktop/Dev/fin-trakaa/node_modules/@nivo/annotations/src/compute.ts","/Users/ilerioluwakiiye/Desktop/Dev/fin-trakaa/node_modules/@nivo/annotations/src/hooks.ts","/Users/ilerioluwakiiye/Desktop/Dev/fin-trakaa/node_modules/@nivo/annotations/src/AnnotationNote.tsx","/Users/ilerioluwakiiye/Desktop/Dev/fin-trakaa/node_modules/@nivo/annotations/src/AnnotationLink.tsx","/Users/ilerioluwakiiye/Desktop/Dev/fin-trakaa/node_modules/@nivo/annotations/src/CircleAnnotationOutline.tsx","/Users/ilerioluwakiiye/Desktop/Dev/fin-trakaa/node_modules/@nivo/annotations/src/DotAnnotationOutline.tsx","/Users/ilerioluwakiiye/Desktop/Dev/fin-trakaa/node_modules/@nivo/annotations/src/RectAnnotationOutline.tsx","/Users/ilerioluwakiiye/Desktop/Dev/fin-trakaa/node_modules/@nivo/annotations/src/Annotation.tsx","/Users/ilerioluwakiiye/Desktop/Dev/fin-trakaa/node_modules/@nivo/annotations/src/canvas.ts"],"sourcesContent":["export const defaultProps = {\n    dotSize: 4,\n    noteWidth: 120,\n    noteTextOffset: 8,\n    animate: true,\n    motionStiffness: 90,\n    motionDamping: 13,\n}\n","import {\n    AnnotationSpec,\n    CircleAnnotationSpec,\n    DotAnnotationSpec,\n    Note,\n    NoteCanvas,\n    NoteSvg,\n    RectAnnotationSpec,\n} from './types'\nimport { isValidElement } from 'react'\n\nexport const isSvgNote = <Datum>(note: Note<Datum>): note is NoteSvg<Datum> => {\n    const noteType = typeof note\n\n    return (\n        isValidElement(note) ||\n        noteType === 'string' ||\n        noteType === 'function' ||\n        noteType === 'object'\n    )\n}\n\nexport const isCanvasNote = <Datum>(note: Note<Datum>): note is NoteCanvas<Datum> => {\n    const noteType = typeof note\n\n    return noteType === 'string' || noteType === 'function'\n}\n\nexport const isCircleAnnotation = <Datum>(\n    annotationSpec: AnnotationSpec<Datum>\n): annotationSpec is CircleAnnotationSpec<Datum> => annotationSpec.type === 'circle'\n\nexport const isDotAnnotation = <Datum>(\n    annotationSpec: AnnotationSpec<Datum>\n): annotationSpec is DotAnnotationSpec<Datum> => annotationSpec.type === 'dot'\n\nexport const isRectAnnotation = <Datum>(\n    annotationSpec: AnnotationSpec<Datum>\n): annotationSpec is RectAnnotationSpec<Datum> => annotationSpec.type === 'rect'\n","import { filter, isNumber, omit } from 'lodash'\nimport {\n    radiansToDegrees,\n    absoluteAngleDegrees,\n    degreesToRadians,\n    positionFromAngle,\n} from '@nivo/core'\nimport { defaultProps } from './props'\nimport {\n    AnnotationPositionGetter,\n    AnnotationDimensionsGetter,\n    BoundAnnotation,\n    AnnotationMatcher,\n    AnnotationInstructions,\n} from './types'\nimport { isCircleAnnotation, isRectAnnotation } from './utils'\n\nexport const bindAnnotations = <\n    Datum = {\n        x: number\n        y: number\n    }\n>({\n    data,\n    annotations,\n    getPosition,\n    getDimensions,\n}: {\n    data: Datum[]\n    annotations: AnnotationMatcher<Datum>[]\n    getPosition: AnnotationPositionGetter<Datum>\n    getDimensions: AnnotationDimensionsGetter<Datum>\n}): BoundAnnotation<Datum>[] =>\n    annotations.reduce((acc: BoundAnnotation<Datum>[], annotation) => {\n        const offset = annotation.offset || 0\n\n        return [\n            ...acc,\n            ...filter<Datum>(data, annotation.match).map(datum => {\n                const position = getPosition(datum)\n                const dimensions = getDimensions(datum)\n\n                if (isCircleAnnotation(annotation) || isRectAnnotation(annotation)) {\n                    dimensions.size = dimensions.size + offset * 2\n                    dimensions.width = dimensions.width + offset * 2\n                    dimensions.height = dimensions.height + offset * 2\n                }\n\n                // acc.push({\n                //     ...omit(annotation, ['match', 'offset']),\n                //     ...position,\n                //     ...dimensions,\n                //     size: annotation.size || dimensions.size,\n                //     datum,\n                // } as any)\n                // return [\n                //     ...acc,\n                //     {\n                //         ...omit(annotation, ['match', 'offset']),\n                //         ...position,\n                //         ...dimensions,\n                //         size: annotation.size || dimensions.size,\n                //         datum,\n                //     },\n                // ]\n                return {\n                    ...omit(annotation, ['match', 'offset']),\n                    ...position,\n                    ...dimensions,\n                    size: annotation.size || dimensions.size,\n                    datum,\n                } as Required<BoundAnnotation<Datum>>\n            }),\n        ]\n\n        // return acc\n    }, [])\n\nexport const getLinkAngle = (\n    sourceX: number,\n    sourceY: number,\n    targetX: number,\n    targetY: number\n) => {\n    const angle = Math.atan2(targetY - sourceY, targetX - sourceX)\n\n    return absoluteAngleDegrees(radiansToDegrees(angle))\n}\n\nexport const computeAnnotation = <Datum>(\n    annotation: BoundAnnotation<Datum>\n): AnnotationInstructions => {\n    const {\n        x,\n        y,\n        noteX,\n        noteY,\n        noteWidth = defaultProps.noteWidth,\n        noteTextOffset = defaultProps.noteTextOffset,\n    } = annotation\n\n    let computedNoteX: number\n    let computedNoteY: number\n\n    if (isNumber(noteX)) {\n        computedNoteX = x + noteX\n    } else if (noteX.abs !== undefined) {\n        computedNoteX = noteX.abs\n    } else {\n        throw new Error(`noteX should be either a number or an object containing an 'abs' property`)\n    }\n\n    if (isNumber(noteY)) {\n        computedNoteY = y + noteY\n    } else if (noteY.abs !== undefined) {\n        computedNoteY = noteY.abs\n    } else {\n        throw new Error(`noteY should be either a number or an object containing an 'abs' property`)\n    }\n\n    let computedX = x\n    let computedY = y\n\n    const angle = getLinkAngle(x, y, computedNoteX, computedNoteY)\n\n    if (isCircleAnnotation<Datum>(annotation)) {\n        const position = positionFromAngle(degreesToRadians(angle), annotation.size / 2)\n        computedX += position.x\n        computedY += position.y\n    }\n\n    if (isRectAnnotation<Datum>(annotation)) {\n        const eighth = Math.round((angle + 90) / 45) % 8\n        if (eighth === 0) {\n            computedY -= annotation.height / 2\n        }\n        if (eighth === 1) {\n            computedX += annotation.width / 2\n            computedY -= annotation.height / 2\n        }\n        if (eighth === 2) {\n            computedX += annotation.width / 2\n        }\n        if (eighth === 3) {\n            computedX += annotation.width / 2\n            computedY += annotation.height / 2\n        }\n        if (eighth === 4) {\n            computedY += annotation.height / 2\n        }\n        if (eighth === 5) {\n            computedX -= annotation.width / 2\n            computedY += annotation.height / 2\n        }\n        if (eighth === 6) {\n            computedX -= annotation.width / 2\n        }\n        if (eighth === 7) {\n            computedX -= annotation.width / 2\n            computedY -= annotation.height / 2\n        }\n    }\n\n    let textX = computedNoteX\n    const textY = computedNoteY - noteTextOffset\n\n    let noteLineX = computedNoteX\n    const noteLineY = computedNoteY\n\n    if ((angle + 90) % 360 > 180) {\n        textX -= noteWidth\n        noteLineX -= noteWidth\n    } else {\n        noteLineX += noteWidth\n    }\n\n    return {\n        points: [\n            [computedX, computedY],\n            [computedNoteX, computedNoteY],\n            [noteLineX, noteLineY],\n        ] as [number, number][],\n        text: [textX, textY],\n        angle: angle + 90,\n    }\n}\n","import { useMemo } from 'react'\nimport { bindAnnotations, computeAnnotation } from './compute'\nimport {\n    AnnotationDimensionsGetter,\n    AnnotationMatcher,\n    AnnotationPositionGetter,\n    BoundAnnotation,\n} from './types'\n\n/**\n * Bind annotations to a dataset.\n */\nexport const useAnnotations = <Datum>({\n    data,\n    annotations,\n    getPosition,\n    getDimensions,\n}: {\n    data: Datum[]\n    annotations: AnnotationMatcher<Datum>[]\n    getPosition: AnnotationPositionGetter<Datum>\n    getDimensions: AnnotationDimensionsGetter<Datum>\n}) =>\n    useMemo(\n        () =>\n            bindAnnotations<Datum>({\n                data,\n                annotations,\n                getPosition,\n                getDimensions,\n            }),\n        [data, annotations, getPosition, getDimensions]\n    )\n\nexport const useComputedAnnotations = <Datum>({\n    annotations,\n}: {\n    annotations: BoundAnnotation<Datum>[]\n}) =>\n    useMemo(\n        () =>\n            annotations.map(annotation => ({\n                ...annotation,\n                computed: computeAnnotation<Datum>({\n                    ...annotation,\n                }),\n            })),\n        [annotations]\n    )\n\nexport const useComputedAnnotation = <Datum>(annotation: BoundAnnotation<Datum>) =>\n    useMemo(() => computeAnnotation<Datum>(annotation), [annotation])\n","import { createElement } from 'react'\nimport omit from 'lodash/omit'\nimport { useSpring, animated } from '@react-spring/web'\nimport { useTheme, useMotionConfig } from '@nivo/core'\nimport { NoteSvg } from './types'\n\nexport const AnnotationNote = <Datum,>({\n    datum,\n    x,\n    y,\n    note,\n}: {\n    datum: Datum\n    x: number\n    y: number\n    note: NoteSvg<Datum>\n}) => {\n    const theme = useTheme()\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedProps = useSpring({\n        x,\n        y,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    if (typeof note === 'function') {\n        return createElement(note, { x, y, datum })\n    }\n\n    return (\n        <>\n            {theme.annotations.text.outlineWidth > 0 && (\n                <animated.text\n                    x={animatedProps.x}\n                    y={animatedProps.y}\n                    style={{\n                        ...theme.annotations.text,\n                        strokeLinejoin: 'round',\n                        strokeWidth: theme.annotations.text.outlineWidth * 2,\n                        stroke: theme.annotations.text.outlineColor,\n                    }}\n                >\n                    {note}\n                </animated.text>\n            )}\n            <animated.text\n                x={animatedProps.x}\n                y={animatedProps.y}\n                style={omit(theme.annotations.text, ['outlineWidth', 'outlineColor'])}\n            >\n                {note}\n            </animated.text>\n        </>\n    )\n}\n","import { useMemo } from 'react'\nimport { animated } from '@react-spring/web'\nimport { useAnimatedPath, useTheme } from '@nivo/core'\n\nexport const AnnotationLink = ({\n    points,\n    isOutline = false,\n}: {\n    points: [number, number][]\n    isOutline?: boolean\n}) => {\n    const theme = useTheme()\n\n    const path = useMemo(() => {\n        const [firstPoint, ...otherPoints] = points\n\n        return otherPoints.reduce(\n            (acc, [x, y]) => `${acc} L${x},${y}`,\n            `M${firstPoint[0]},${firstPoint[1]}`\n        )\n    }, [points])\n\n    const animatedPath = useAnimatedPath(path)\n\n    if (isOutline && theme.annotations.link.outlineWidth <= 0) {\n        return null\n    }\n\n    const style = { ...theme.annotations.link }\n    if (isOutline) {\n        style.strokeLinecap = 'square'\n        style.strokeWidth =\n            theme.annotations.link.strokeWidth + theme.annotations.link.outlineWidth * 2\n        style.stroke = theme.annotations.link.outlineColor\n        style.opacity = theme.annotations.link.outlineOpacity\n    }\n\n    return <animated.path fill=\"none\" d={animatedPath} style={style} />\n}\n","import { useSpring, animated } from '@react-spring/web'\nimport { useMotionConfig, useTheme } from '@nivo/core'\n\nexport const CircleAnnotationOutline = ({ x, y, size }: { x: number; y: number; size: number }) => {\n    const theme = useTheme()\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedProps = useSpring({\n        x,\n        y,\n        radius: size / 2,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <>\n            {theme.annotations.outline.outlineWidth > 0 && (\n                <animated.circle\n                    cx={animatedProps.x}\n                    cy={animatedProps.y}\n                    r={animatedProps.radius}\n                    style={{\n                        ...theme.annotations.outline,\n                        fill: 'none',\n                        strokeWidth:\n                            theme.annotations.outline.strokeWidth +\n                            theme.annotations.outline.outlineWidth * 2,\n                        stroke: theme.annotations.outline.outlineColor,\n                        opacity: theme.annotations.outline.outlineOpacity,\n                    }}\n                />\n            )}\n            <animated.circle\n                cx={animatedProps.x}\n                cy={animatedProps.y}\n                r={animatedProps.radius}\n                style={theme.annotations.outline}\n            />\n        </>\n    )\n}\n","import { useSpring, animated } from '@react-spring/web'\nimport { useMotionConfig, useTheme } from '@nivo/core'\nimport { defaultProps } from './props'\n\nexport const DotAnnotationOutline = ({\n    x,\n    y,\n    size = defaultProps.dotSize,\n}: {\n    x: number\n    y: number\n    size?: number\n}) => {\n    const theme = useTheme()\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedProps = useSpring({\n        x,\n        y,\n        radius: size / 2,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <>\n            {theme.annotations.outline.outlineWidth > 0 && (\n                <animated.circle\n                    cx={animatedProps.x}\n                    cy={animatedProps.y}\n                    r={animatedProps.radius}\n                    style={{\n                        ...theme.annotations.outline,\n                        fill: 'none',\n                        strokeWidth: theme.annotations.outline.outlineWidth * 2,\n                        stroke: theme.annotations.outline.outlineColor,\n                        opacity: theme.annotations.outline.outlineOpacity,\n                    }}\n                />\n            )}\n            <animated.circle\n                cx={animatedProps.x}\n                cy={animatedProps.y}\n                r={animatedProps.radius}\n                style={theme.annotations.symbol}\n            />\n        </>\n    )\n}\n","import { useSpring, animated } from '@react-spring/web'\nimport { useMotionConfig, useTheme } from '@nivo/core'\n\nexport const RectAnnotationOutline = ({\n    x,\n    y,\n    width,\n    height,\n    borderRadius = 6,\n}: {\n    x: number\n    y: number\n    width: number\n    height: number\n    borderRadius?: number\n}) => {\n    const theme = useTheme()\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedProps = useSpring({\n        x: x - width / 2,\n        y: y - height / 2,\n        width,\n        height,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <>\n            {theme.annotations.outline.outlineWidth > 0 && (\n                <animated.rect\n                    x={animatedProps.x}\n                    y={animatedProps.y}\n                    rx={borderRadius}\n                    ry={borderRadius}\n                    width={animatedProps.width}\n                    height={animatedProps.height}\n                    style={{\n                        ...theme.annotations.outline,\n                        fill: 'none',\n                        strokeWidth:\n                            theme.annotations.outline.strokeWidth +\n                            theme.annotations.outline.outlineWidth * 2,\n                        stroke: theme.annotations.outline.outlineColor,\n                        opacity: theme.annotations.outline.outlineOpacity,\n                    }}\n                />\n            )}\n            <animated.rect\n                x={animatedProps.x}\n                y={animatedProps.y}\n                rx={borderRadius}\n                ry={borderRadius}\n                width={animatedProps.width}\n                height={animatedProps.height}\n                style={theme.annotations.outline}\n            />\n        </>\n    )\n}\n","import { useComputedAnnotation } from './hooks'\nimport { AnnotationNote } from './AnnotationNote'\nimport { AnnotationLink } from './AnnotationLink'\nimport { CircleAnnotationOutline } from './CircleAnnotationOutline'\nimport { DotAnnotationOutline } from './DotAnnotationOutline'\nimport { RectAnnotationOutline } from './RectAnnotationOutline'\nimport { BoundAnnotation } from './types'\nimport { isCircleAnnotation, isDotAnnotation, isRectAnnotation, isSvgNote } from './utils'\n\nexport const Annotation = <Datum,>(annotation: BoundAnnotation<Datum>) => {\n    const { datum, x, y, note } = annotation\n    const computed = useComputedAnnotation(annotation)\n\n    if (!isSvgNote(note)) {\n        throw new Error('note should be a valid react element')\n    }\n\n    return (\n        <>\n            <AnnotationLink points={computed.points} isOutline={true} />\n            {isCircleAnnotation(annotation) && (\n                <CircleAnnotationOutline x={x} y={y} size={annotation.size} />\n            )}\n            {isDotAnnotation(annotation) && (\n                <DotAnnotationOutline x={x} y={y} size={annotation.size} />\n            )}\n            {isRectAnnotation(annotation) && (\n                <RectAnnotationOutline\n                    x={x}\n                    y={y}\n                    width={annotation.width}\n                    height={annotation.height}\n                    borderRadius={annotation.borderRadius}\n                />\n            )}\n            <AnnotationLink points={computed.points} />\n            <AnnotationNote datum={datum} x={computed.text[0]} y={computed.text[1]} note={note} />\n        </>\n    )\n}\n","import { CompleteTheme } from '@nivo/core'\nimport { ComputedAnnotation } from './types'\nimport { isCanvasNote, isCircleAnnotation, isDotAnnotation, isRectAnnotation } from './utils'\n\nconst drawPoints = (ctx: CanvasRenderingContext2D, points: [number, number][]) => {\n    points.forEach(([x, y], index) => {\n        if (index === 0) {\n            ctx.moveTo(x, y)\n        } else {\n            ctx.lineTo(x, y)\n        }\n    })\n}\n\nexport const renderAnnotationsToCanvas = <Datum>(\n    ctx: CanvasRenderingContext2D,\n    {\n        annotations,\n        theme,\n    }: {\n        annotations: ComputedAnnotation<Datum>[]\n        theme: CompleteTheme\n    }\n) => {\n    if (annotations.length === 0) return\n\n    ctx.save()\n    annotations.forEach(annotation => {\n        if (!isCanvasNote(annotation.note)) {\n            throw new Error('note is invalid for canvas implementation')\n        }\n\n        if (theme.annotations.link.outlineWidth > 0) {\n            ctx.lineCap = 'square'\n            ctx.strokeStyle = theme.annotations.link.outlineColor\n            ctx.lineWidth =\n                theme.annotations.link.strokeWidth + theme.annotations.link.outlineWidth * 2\n            ctx.beginPath()\n            drawPoints(ctx, annotation.computed.points)\n            ctx.stroke()\n            ctx.lineCap = 'butt'\n        }\n\n        if (isCircleAnnotation(annotation) && theme.annotations.outline.outlineWidth > 0) {\n            ctx.strokeStyle = theme.annotations.outline.outlineColor\n            ctx.lineWidth =\n                theme.annotations.outline.strokeWidth + theme.annotations.outline.outlineWidth * 2\n            ctx.beginPath()\n            ctx.arc(annotation.x, annotation.y, annotation.size / 2, 0, 2 * Math.PI)\n            ctx.stroke()\n        }\n\n        if (isDotAnnotation(annotation) && theme.annotations.symbol.outlineWidth > 0) {\n            ctx.strokeStyle = theme.annotations.symbol.outlineColor\n            ctx.lineWidth = theme.annotations.symbol.outlineWidth * 2\n            ctx.beginPath()\n            ctx.arc(annotation.x, annotation.y, annotation.size / 2, 0, 2 * Math.PI)\n            ctx.stroke()\n        }\n\n        if (isRectAnnotation(annotation) && theme.annotations.outline.outlineWidth > 0) {\n            ctx.strokeStyle = theme.annotations.outline.outlineColor\n            ctx.lineWidth =\n                theme.annotations.outline.strokeWidth + theme.annotations.outline.outlineWidth * 2\n            ctx.beginPath()\n            ctx.rect(\n                annotation.x - annotation.width / 2,\n                annotation.y - annotation.height / 2,\n                annotation.width,\n                annotation.height\n            )\n            ctx.stroke()\n        }\n\n        ctx.strokeStyle = theme.annotations.link.stroke\n        ctx.lineWidth = theme.annotations.link.strokeWidth\n        ctx.beginPath()\n        drawPoints(ctx, annotation.computed.points)\n        ctx.stroke()\n\n        if (isCircleAnnotation(annotation)) {\n            ctx.strokeStyle = theme.annotations.outline.stroke\n            ctx.lineWidth = theme.annotations.outline.strokeWidth\n            ctx.beginPath()\n            ctx.arc(annotation.x, annotation.y, annotation.size / 2, 0, 2 * Math.PI)\n            ctx.stroke()\n        }\n\n        if (isDotAnnotation(annotation)) {\n            ctx.fillStyle = theme.annotations.symbol.fill\n            ctx.beginPath()\n            ctx.arc(annotation.x, annotation.y, annotation.size / 2, 0, 2 * Math.PI)\n            ctx.fill()\n        }\n\n        if (isRectAnnotation(annotation)) {\n            ctx.strokeStyle = theme.annotations.outline.stroke\n            ctx.lineWidth = theme.annotations.outline.strokeWidth\n            ctx.beginPath()\n            ctx.rect(\n                annotation.x - annotation.width / 2,\n                annotation.y - annotation.height / 2,\n                annotation.width,\n                annotation.height\n            )\n            ctx.stroke()\n        }\n\n        if (typeof annotation.note === 'function') {\n            annotation.note(ctx, {\n                datum: annotation.datum,\n                x: annotation.computed.text[0],\n                y: annotation.computed.text[1],\n                theme,\n            })\n        } else {\n            ctx.font = `${theme.annotations.text.fontSize}px ${theme.annotations.text.fontFamily}`\n            ctx.textAlign = 'left'\n            ctx.textBaseline = 'alphabetic'\n\n            ctx.fillStyle = theme.annotations.text.fill\n            ctx.strokeStyle = theme.annotations.text.outlineColor\n            ctx.lineWidth = theme.annotations.text.outlineWidth * 2\n\n            if (theme.annotations.text.outlineWidth > 0) {\n                ctx.lineJoin = 'round'\n                ctx.strokeText(\n                    annotation.note,\n                    annotation.computed.text[0],\n                    annotation.computed.text[1]\n                )\n                ctx.lineJoin = 'miter'\n            }\n            ctx.fillText(annotation.note, annotation.computed.text[0], annotation.computed.text[1])\n        }\n    })\n    ctx.restore()\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}